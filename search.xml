<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[myTest]]></title>
      <url>http://www.pangjian.me/2017/11/02/myTest/</url>
      <content type="html"><![CDATA[<p>ǰ�������й����˲��͵�ʱ���������䷢�����и��˵Ĳ��ͷ����ٶȼ��죬���Ǻ������о���һ�¡��ڲ鿴������ʱ��������һ��<code>jquery.pjax.min.js</code>���������˲����ϣ���ȷʵ���ٶȿ���ԭ����<br><code>Pjax</code>����Ҫԭ��������<code>ajax</code>�첽����ҳ�沢�ֲ�ˢ�£�����<code>pushState</code>�޸�url��history�������ͼ�ӵ����<code>ajax</code>�ֲ�ˢ�µ����ƣ�ͬʱҲ������ֻ����<code>ajax</code>�ĵ�ҳ��Ӧ��url�����仯��������SEO������������������ǰ������ҲʧЧ�����⡣
  <a href="http://www.github.io" target="_blank" rel="external">github</a>��Google+����ʹ�������ļ������������ϵ��ŵ����⣬ҳ���л��������������������������Լ��Ĺ��ȶ�������Ҳ��ʵ�������������ǳ������ھ�̬��������ÿ��ҳ���л�����ֻ���������ݻ��仯��������</p>
<p>���ĵ�����ּ�ڼ�¼����������pjax�Ĺ��̣�Ч�����Բο�<a href="http://www.pangjian.info" target="_blank" rel="external">������</a>�����Ľ���������������ָjQuery�����棬���Բ鿴github�ϵ�<a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="external">jquery-pjax</a>��</p>
<h1 id="Ч��"><a href="#Ч��" class="headerlink" title="Ч��"></a>Ч��</h1>
<p>�������棬�ȿ���Ч������pjaxǰ�л�һ��ҳ��������<br><img src="/resources/using-pjax/pajax_before.png" alt="����pjaxǰ"></p>
<p>����pjax��…<br><img src="/resources/using-pjax/pjax_after.png" alt="����pjax��"><br>Ч�����Ǻ����Եģ��������ٵ���3�Σ������Ѿ���������Դ�ļ�����û��ˢ�£�û���ظ��������ٶ�Ҳ���������ˡ�</p>]]></content>
      
        
    </entry>
    
    <entry>
      <title><![CDATA[全站HTTPS改造]]></title>
      <url>http://www.pangjian.me/2017/01/24/whole-site-https/</url>
      <content type="html"><![CDATA[<p>HTTPS大势已来，2016年6月苹果宣布要求所有iOS Apps在2017年初全部使用HTTPS，11月Google宣布，从17年1月开始，对没有使用HTTPS的网站竖起“不安全”的小红旗。15年，淘宝、天猫也启动了HTTPS迁移。国内网络环境也不太好，经常会有运营商篡改页面的情况，为了更安全的客户体验，避免各种情况同事顺应大势所趋，本博客也进行了全站HTTPS化。<br>
  <a id="more"></a>
</p>
<h1 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h1>
<p>我使用的是<a href="https://letsencrypt.org" target="_blank" rel="external">Let’s Encrypt</a>证书,它由ISRG（Internet Security Research Group，互联网安全研究小组）提供服务。Let’s Encrypt得到了众多大公司和机构的支持，比如Mozilla、Cisco、Chrome等。近期发展十分迅猛。<br>Let’s Encrypt的申请是免费的，但是有90天的有效期。但是可以通过脚本自动更新，配置以后就一劳永逸了。配置参考了Jerry Qu的博客文章
  <a href="https://imququ.com/post/letsencrypt-certificate.html" target="_blank" rel="external">Let’s Encrypt，免费好用的 HTTPS 证书</a>。过程讲解的非常详细，本处就不在赘述，贴上过程使用命令以备后查。</p>
<h2 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h2>
<p>先创建一个<code>ssl</code>文件夹用来存放文件<br>
  <figure class="highlight bash">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">openssl genrsa <span class="number">4096</span> &gt; account.key</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="创建CSR文件"><a href="#创建CSR文件" class="headerlink" title="创建CSR文件"></a>创建CSR文件</h2>
<p>创建ECC私钥<br>
  <figure class="highlight bash">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">openssl ecparam -genkey -name secp256r1 | openssl ec -out domain.key</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>生成CSR文件<br>
  <figure class="highlight bash">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">openssl req -new -sha256 -key domain.key -subj <span class="string">"/"</span> -reqexts SAN -config &lt;(cat /etc/ssl/openssl.cnf &lt;(<span class="built_in">printf</span> <span class="string">"[SAN]\nsubjectAltName=DNS:pangjian.me,DNS:www.pangjian.me"</span>)) &gt; domain.csr</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="配置验证服务"><a href="#配置验证服务" class="headerlink" title="配置验证服务"></a>配置验证服务</h2>
<p>此过程非常重要，用来和Let’s Encrypt验证域名的控制权。采用<code>acme-tiny</code>脚本<br>先创建一个验证文件夹，比如<code>/home/pangjian/www/challenges</code>，然后配置一个HTTP服务</p>
<figure class="highlight nginx">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line"><span class="title">server</span> &#123;</span><br><span class="line">    <span class="title">server_name</span> www.pangjian.me pangjian.me;</span><br><span class="line"></span><br><span class="line">    <span class="title">location</span><span class="regexp"> ^~</span> /.well-known/acme-challenge/ &#123;</span><br><span class="line">        <span class="title">alias</span> /home/pangjian/www/challenges/;</span><br><span class="line">        <span class="title">try_files</span> <span class="variable">$uri</span> =<span class="number">404</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title">location</span> / &#123;</span><br><span class="line">        <span class="title">rewrite</span><span class="regexp"> ^/(.*)$</span> <span class="url">https://www.pangjian.me/<span class="variable">$1</span></span> <span class="built_in">permanent</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>下载<code>acme-tiny</code>脚本并执行</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">wget https://raw.githubusercontent.com/diafygi/acme-tiny/master/acme_tiny.py</span><br><span class="line">python acme_tiny.py --account-key ./account.key --csr ./domain.csr --acme-dir /home/pangjian/www/challenges &gt; ./signed.crt</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>过程就是脚本先在指定文件夹生成一个验证文件，通过http服务可以下载，Let’s Encrypt来访问你的服务下载文件，达到验证效果。<br>下载中间证书，并将网站证书和中间证书结合在一起</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>至此，证书申请完毕，但是有90天的有效期限制，需要配置自动更新。用crontab定期执行acme_tiny脚本就OK啦。</p>
<h2 id="自动更新"><a href="#自动更新" class="headerlink" title="自动更新"></a>自动更新</h2>
<p>renew_cert.sh内容</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line"><span class="shebang">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cd</span> /home/pangjian/ssl/</span><br><span class="line">python acme_tiny.py --account-key account.key --csr domain.csr --acme-dir /home/pangjian/www/challenges &gt; signed.crt || <span class="built_in">exit</span></span><br><span class="line">wget -O - https://letsencrypt.org/certs/lets-encrypt-x3-cross-signed.pem &gt; intermediate.pem</span><br><span class="line">cat signed.crt intermediate.pem &gt; chained.pem</span><br><span class="line">service nginx reload</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>执行<code>crontab -e</code>，输入以下内容<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">0 0 1 * * /home/pangjian/ssl/renew_cert.sh &#62;/dev/null 2&#62;&#38;1</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h1 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h1>
<p>在Nginx配置中增加上证书信息<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">ssl_certificate     /home/pangjian/ssl/chained.pem;&#10;ssl_certificate_key /home/pangjian/ssl/domain.key;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>在http的服务中除了验证服务以外，其他请求都rewrite到https服务下，<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">location / &#123;&#10;        rewrite ^/(.*)$ https://www.pangjian.me/$1 permanent;&#10;    &#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h1 id="静态资源和多说https化"><a href="#静态资源和多说https化" class="headerlink" title="静态资源和多说https化"></a>静态资源和多说https化</h1>
<p>多说原先不支持Https是一直被人诟病和转战Disqus的理由，要实现全站HTTPS必然要搞定多说。首先，多说官方说除了第三方头像其他的都已经支持https，但是头像也不能忽视啊，况且第三方已经支持https了。我下载了多说的js进行了修改，成功将头像、表情转换为https。<br>首先先下载多说的<a href="https://static.duoshuo.com/embed.js" target="_blank" rel="external"><code>embed.js</code></a>，</p>
<h2 id="修改头像链接"><a href="#修改头像链接" class="headerlink" title="修改头像链接"></a>修改头像链接</h2>
<p>搜索avatar_url，对url进行字符串替换<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">avatarUrl: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = e.avatar_url || rt.data.default_avatar_url;</span><br><span class="line">  s=s.replace(<span class="regexp">/http:/g</span>,<span class="string">'https:'</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;,</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="修改表情链接"><a href="#修改表情链接" class="headerlink" title="修改表情链接"></a>修改表情链接</h2>
<figure class="highlight javascript">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line"><span class="keyword">var</span> t = <span class="string">""</span></span><br><span class="line">, s = e.post</span><br><span class="line">, i = e.options</span><br><span class="line">, r = s.author;</span><br><span class="line">s.message = s.message.replace(<span class="regexp">/http:/g</span>, <span class="string">'https:'</span>)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>全站HTTPS改造完毕，看见这个绿色的小锁，心情真好！<br><img src="/resources/whole-site-https/httpsdone.png" alt="https"></p>
<h2 id="安全测试"><a href="#安全测试" class="headerlink" title="安全测试"></a>安全测试</h2>
<p><img src="/resources/whole-site-https/sslreport.png" alt="安全测试报告"></p>
<p><a href="https://www.ssllabs.com/ssltest/analyze.html?d=www.pangjian.me" target="_blank" rel="external">查看完整的测试结果&gt;&gt;</a></p>
<p>EOF<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2017/01/24/whole-site-https/</p><p>访问原文「<a href='http://www.pangjian.me/2017/01/24/whole-site-https/'>全站HTTPS改造</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> https </tag>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nodejs部署方式-pm2(一)]]></title>
      <url>http://www.pangjian.me/2016/12/02/deploy-nodejs-pm2-1/</url>
      <content type="html"><![CDATA[<p>目前Nodejs开发中有很多痛点，其中有一个是修改完代码以后需要我们重启服务才能看到效果。这样一次次的杀进程、重启，杀进程、重启很让人头大。程序员是最痛恨重复工作的物种，之前有了解过的同学可能知道<code>forever</code>。<code>forever</code>可以帮我们解决上面的问题，通过对资源变化的检测做到变化后自动重启。开发阶段我们使用<code>node file.js</code>来启动另外由于Nodejs的单线程，任何异常都会导致整个服务中断，这对于生产上长时间提供服务的程序来讲是不可以的，<code>forever</code>可以帮我们在异常后重启，保证服务一直在线，我想这也就是它名字的由来吧。但我想说的是<code>forever</code>不够“高！大！上！”。接下来我要介绍一个足够高大上的神器–
  <a href="http://pm2.keymetrics.io" target="_blank" rel="external"><code>pm2</code></a>。</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
<p><code>pm2</code>=<strong>P</strong>(rocess) <strong>M</strong>(anager)2，是可以用于生产环境的Nodejs的进程管理工具，并且它内置一个负载均衡。它不仅可以保证服务不会中断一直在线，并且提供0秒reload功能，还有其他一系列进程管理、监控功能。并且使用起来非常简单。下面我将把我的使用过程分享出来，Nodejs应用是一个基于Express 4.x的应用，名称是<code>Wolverine</code>。</p>
<a id="more"></a>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1>
<p>环境清单：</p>
<ul>
  <li>windows7 x64</li>
  <li>node v5.0.0</li>
  <li>npm 3.3.6</li>
</ul>
<p>全局安装<code>pm2</code></p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ npm install pm2 -g</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>更新<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ pm2 update</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1>
<p>以前启动<code>Wolverine</code>是利用package.json的<code>scripts</code>来实现的，只需要执行<code>npm run start</code>就可以启动，配置如下：</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">&#34;scripts&#34;: &#123;&#10;    &#34;start&#34;: &#34;node ./bin/www&#34;,&#10;    &#34;debug&#34;: &#34;node debug ./bin/www&#34;&#10;&#10;  &#125;,</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>使用<code>pm2</code>我们可以在start处配置成 <code>pm2 ./bin/www</code>,命令后面支持加参数来实现watch、cluster多进程模式等功能。我不太喜欢一大串的命令，于是我使用了配置文件的方式。<br>在<code>Wolverine</code>的根目录，我创建了一个<code>processes.json</code>配置文件，配置文件内容如下，注释写的也很清楚了</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">&#123;&#10;  &#34;apps&#34; : [&#123;&#10;    &#34;name&#34; : &#34;Wolverine&#34;,  //&#21517;&#31216;&#10;    &#34;script&#34;: &#34;./bin/www&#34;, //&#31243;&#24207;&#20837;&#24211;&#10;    &#34;cwd&#34;: &#34;./&#34;,           //&#26681;&#30446;&#24405;&#10;    &#34;watch&#34;:[&#10;&#9;&#9;&#34;bin&#34;,&#10;&#9;&#9;&#34;common&#34;,&#10;&#9;&#9;&#34;configs&#34;,&#10;&#9;&#9;&#34;public&#34;,&#10;&#9;&#9;&#34;routes&#34;,&#10;&#9;&#9;&#34;views&#34;&#10;&#9;],//&#38656;&#35201;&#30417;&#25511;&#30340;&#30446;&#24405;&#10;    &#34;error_file&#34;:&#34;./logs/app-err.log&#34;,//&#38169;&#35823;&#36755;&#20986;&#26085;&#24535;&#10;    &#34;out_file&#34;:&#34;./logs/app-out.log&#34;,  //&#26085;&#24535;&#10;    &#34;log_date_format&#34;:&#34;YYYY-MM-DD HH:mm Z&#34; //&#26085;&#26399;&#26684;&#24335;&#10;    &#125;]&#10;&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>随后，我在package.json中增加了一条<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#34;pm2&#34;: &#34;pm2 start processes.json&#34;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>在启动就直接输入如下命令就好：<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ npm run pm2</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>看到下面的界面，就启动成功了，然后我们就可以关掉这个窗口了，服务不会因此停止，是不是高大上多了。<br><img src="/resources/deploy-nodejs-pm2-1/pm2-start.png" alt="pm2启动界面"></p>
<h1 id="管理和监控"><a href="#管理和监控" class="headerlink" title="管理和监控"></a>管理和监控</h1>
<p>启动成功的界面会展示App name和id，这两个值很重要。当然这两个值都可以在processes.json配置文件进行配置。<br>打开命令行，在任何路径下，输入<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ pm2 list</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>就能看到启动时的图表界面，方便我们查看所有通过pm2管理的Nodejs服务。</p>
<p>输入,下面命令配合id或者name可以查看某一个进程的详细信息<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ pm2 show Wolverine &#25110;&#32773;&#10;$ pm2 show 0</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p><img src="/resources/deploy-nodejs-pm2-1/pm2-list.png" alt="pm2 list"><br>内容涉及重启次数、运行时间、脚本路径、参数、日志路径、运行模式等等信息<br>输入<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ pm2 monit</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>停止、重启等命令</p>
<figure class="highlight bash">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ pm2 stop [app-name|id]  <span class="comment">#停止某一个进程，可以使用app-name或者id</span></span><br><span class="line">$ pm2 stop all            <span class="comment">#停止所有进程</span></span><br><span class="line"></span><br><span class="line">$ pm2 restart all         <span class="comment">#重启所有的进程</span></span><br><span class="line"></span><br><span class="line">$ pm2 delete [app-name|id]<span class="comment">#删除并停止进程</span></span><br><span class="line">$ pm2 delete all          <span class="comment">#删除并停止所有进程</span></span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>可以进一步查看每一个服务的cpu、内存动态占用情况。<br><img src="/resources/deploy-nodejs-pm2-1/pm2-monit.png" alt="pm2 monit"></p>
<h1 id="日志监控"><a href="#日志监控" class="headerlink" title="日志监控"></a>日志监控</h1>
<p>如果你一直使用<code>tail -f log_file.log log_error.log</code>来查看日志，你可能会爱上下面的这个功能。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ pm2 logs&#10;$ pm2 logs [app-name]</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>我们可以实时查看全部进程的日志，或者只查看某一个。我们甚至可以使用json格式查看日志。<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ pm2 logs --json</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h1 id="Web-API"><a href="#Web-API" class="headerlink" title="Web API"></a>Web API</h1>
<p>如果你不仅仅想监控被pm2管理的进程，还需要监控进程所运行的机器的信息，你可以使用下面这个API<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ pm2 web</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>pm2会启动一个叫做pm2-http-interface的进程提供web服务。你打开浏览器输入http：//127.0.0.1:9615，是不是被看到的结果惊艳到了。<br><img src="/resources/deploy-nodejs-pm2-1/pm2-webapi.png" alt="pm2-webapi"><br>pm2提供的web api通过json输出了很多信息。大致结构可以看截图：<br><img src="/resources/deploy-nodejs-pm2-1/pm2-webapi-json.png" alt="pm2-webapi-json"></p>
<p>拿出你的想象力，我们可以开发一个应用来调用此api，就可以开发出一个图形界面的监控软件了。。。</p>
<h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1>
<p>pm2的优势和功能还不止这些，后续还会有文章详述更多高级的用法，比如进程恢复、图形界面，模块，甚至的功能开发。最重要的优势我想就是它的稳定性了，pm2的功能全部通过了测试，有超过1000个测试。同时提供Windows、MacOSX（OSX）、Linux的稳定版本。PayPal、微软、IBM等等大厂都在使用。我们已经有充分的理由把它应用到生产环境上。<br>EOF<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2016/12/02/deploy-nodejs-pm2-1/</p><p>访问原文「<a href='http://www.pangjian.me/2016/12/02/deploy-nodejs-pm2-1/'>nodejs部署方式-pm2(一)</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> Nodejs </tag>
            
            <tag> pm2 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用CNPM搭建私有NPM仓库]]></title>
      <url>http://www.pangjian.me/2016/06/01/cnmp-local-npm-server/</url>
      <content type="html"><![CDATA[<p>我们在使用Nodejs的时候，使用npm仓库来发布和管理模块，我们可以从npm上下载别人发布的模块使用，也可以自己发布模块，有点类似于Maven，这是非常流行的开源社区模式。但是在企业内部，我们不希望我们的生产代码可以随意引用任何未经企业审核的代码；我们也不希望企业内部自己的模块发布给任意人员使用；还有一个重要的原因是很多企业内部无法连接互联网<code>cnpm</code>就是来解决这些问题的。官方的解释是<code>cnpm</code>=<strong>Company npm</strong></p>
<h1 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h1>
<ul>
  <li>OS：Red Hat Enterprise Linux Server release 6.4 (Santiago)</li>
  <li>node：v4.4.5</li>
  <li>npm：2.15.5</li>
  <li>cnpm：2.10.0（截止到本文发布）</li>
</ul>
<a id="more"></a>
<h1 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h1>
<p><code>cnpmjs.org</code>依赖一个数据库，官方支持<code>sqllite3</code>、<code>MySQL</code>、<code>MariaDB</code>、<code>PostgreSQL</code>中的任何一个，我选择了<code>MySQL</code>。<br>我们的操作系统是Red Hat 6.4，在这个动作之前应当将Red Hat自带的yum替换成CentOS的，此步骤不再赘述。<br>编辑源列表：<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ vim /etc/yum.repos.d/rhel-debuginfo.repo</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>添加如下内容：<br>
  <figure class="highlight coffeescript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">[mysql56]</span><br><span class="line">name=MySQL <span class="number">5.6</span></span><br><span class="line">baseurl=<span class="attribute">http</span>:<span class="regexp">//</span>repo.mysql.com<span class="regexp">/yum/mysql-5.6-community/el/6/</span>$basearch/</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">0</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>然后执行：<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ yum update&#10;$ sudo yum install mysql-community-server&#10;$ sudo service mysqld start</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>安装完成后，创建一个名叫cnpmjs的DATABASE。<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ mysql -u root -p&#10;&#10;mysql&#62; create datebase cnpmjs</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h1 id="安装cnpm"><a href="#安装cnpm" class="headerlink" title="安装cnpm"></a>安装cnpm</h1>
<h2 id="从github下载cnpmjs-org"><a href="#从github下载cnpmjs-org" class="headerlink" title="从github下载cnpmjs.org"></a>从<code>github</code>下载<code>cnpmjs.org</code></h2>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ git clone git://github.com/cnpm/cnpmjs.org.git&#10;$ cd cnpmjs.org&#10;#&#23433;&#35013;&#20381;&#36182;&#10;$ npm install</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>在国内npm缓慢甚至有些模块被墙，可以使用cnpm淘宝的镜像源安装。</p>
<h2 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h2>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">mysql&#62; use cnpmjs;&#10;mysql&#62; source docs/db.sql</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h2>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ vim config/index.js</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>修改数据库配置，找到如下配置，将MySQL的配置填入<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">database: &#123;&#10;    db: &#39;cnpmjs&#39;,&#10;    username: &#39;root&#39;,&#10;    password: &#39;123456&#39;,&#10;&#10;    // the sql dialect of the database&#10;    // - currently supported: &#39;mysql&#39;, &#39;sqlite&#39;, &#39;postgres&#39;, &#39;mariadb&#39;&#10;    dialect: &#39;mysql&#39;,&#10;&#10;    // custom host; default: 127.0.0.1&#10;    host: &#39;127.0.0.1&#39;,&#10;&#10;    // custom port; default: 3306&#10;    port: 3306,&#10;&#10;    // use pooling in order to reduce db connection overload and to increase speed&#10;    // currently only for mysql and postgresql (since v1.5.0)&#10;    pool: &#123;&#10;      maxConnections: 10,&#10;      minConnections: 0,&#10;      maxIdleTime: 30000&#10;    &#125;,&#10;&#10;    // the storage engine for &#39;sqlite&#39;&#10;    // default store into ~/.cnpmjs.org/data.sqlite&#10;    storage: path.join(dataDir, &#39;data.sqlite&#39;),&#10;&#10;    logging: !!process.env.SQL_DEBUG,&#10;  &#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>开启对外服务，注掉以下内容<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">//bindingHost: &#39;127.0.0.1&#39;, // only binding on 127.0.0.1 for local access</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>同步模式，由于硬盘资源有限，我选择了exist只同步已经存在的模块<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">// sync mode select&#10;// none: do not sync any module, proxy all public modules from sourceNpmRegistry&#10;// exist: only sync exist modules&#10;// all: sync all modules&#10;syncModel: &#39;exist&#39;, // &#39;none&#39;, &#39;all&#39;, &#39;exist&#39;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>其他自定义配置，比如管理员、说明文档等等都可以自行修改。</p>
<p>启动<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ npm run start</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>停止<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ npm run stop</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>cnmp启动以后会占用7001和7002两个端口，在iptables中开放这两个端口。<br>打开浏览器输入<code>http://ip:7002</code>，看到如下界面，安装成功。我替换了个Logo<br><img src="/resources/cnpm-local-npm-server/cnpm.png" alt="cnpm"></p>
<h1 id="如何使用私有仓库"><a href="#如何使用私有仓库" class="headerlink" title="如何使用私有仓库"></a>如何使用私有仓库</h1>
<p>当我们使用私有的仓库时，模块就会从私有库中下载，如果私有库中没有，cnpm就会去npm仓库中下载，并保存在私有仓库一份。</p>
<h2 id="下载指定私有库"><a href="#下载指定私有库" class="headerlink" title="下载指定私有库"></a>下载指定私有库</h2>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ npm install debug --registry=http://ip:7001</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>这样，本次下载npm就会从你指定的私有仓库中下载</p>
<h2 id="修改默认库为私有库"><a href="#修改默认库为私有库" class="headerlink" title="修改默认库为私有库"></a>修改默认库为私有库</h2>
<p>如果不希望每一次都设置私有库，可以设置默认配置为私有仓库<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"># &#21015;&#20986;npm&#37197;&#32622;&#10;$ npm config list&#10;&#10;$ npm config set registry http://ip:7001</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>这样，一个私有的npm仓库就算搭建完成了。<br>EOF<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2016/06/01/cnmp-local-npm-server/</p><p>访问原文「<a href='http://www.pangjian.me/2016/06/01/cnmp-local-npm-server/'>使用CNPM搭建私有NPM仓库</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> Nodejs </tag>
            
            <tag> cnpm </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用travis-ci持续集成Hexo静态博客]]></title>
      <url>http://www.pangjian.me/2016/05/25/travis-ci-hexo/</url>
      <content type="html"><![CDATA[<p>Hexo是一个基于Nodejs的轻量级静态博客生成框架。静态博客生成程序会将我们所写的博客生成为一套HTML+CSS+JavaScript代码，我们将这个代码部署到诸如Github Page这样的地方就可以在世界任何一个地方访问我们的博客了。这种方案有一个非常有利的优点–免费。但是，hexo环境不是处处都有，换个地方写作变成了一件麻烦事。而且写完文章以后需要<code>hexo g</code>，<code>hexo d</code>等一系列操作，着实很麻烦。本篇文章利用Travis CI解决以上痛点。<br>
  <a id="more"></a>
</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1>
<p>Travis CI提供一个在线的持续集成服务，用来构建托管在github上的代码。许多知名的开源项目使用它来自动构建测试代码。它支持hexo的运行环境node.js。原理很简单，Travis会在你每一次在github上提交代码后，生成一个Linux虚拟机来运行你配置好的任务。生成和部署hexo只需要一个命令<code>hexo gd</code>，但是Travis CI需要有我们的github项目上传代码的权限，所以我们需要使用SSH key来使Travis CI拥有权限。还有一些其他的问题也都参开hexo作者的博文解决了，
  <a href="http://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="external">用Travis CI自动部署网站到Github</a>
</p>
<h1 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h1>
<h2 id="生成SSHKey"><a href="#生成SSHKey" class="headerlink" title="生成SSHKey"></a>生成SSHKey</h2>
<p>此步骤网上教程较多，此处只是简单介绍。<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">ssh-keygen -t rsa -C &#34;youremail@example.com&#34;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>按要求操作后会生成两个文件<code>id_rsa</code>和<code>id_rsa.pub</code>,然后加入SSH agent。<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>然后，我们将id_rsa.pub中的内容添加到github中，如果你还使用其他Page服务，也需要添加到对应的托管平台。我就在同时使用Coding.net。</p>
<h2 id="加密私钥"><a href="#加密私钥" class="headerlink" title="加密私钥"></a>加密私钥</h2>
<p>我们不可能把代码库的SSH key直接上传到代码库，那样任何人都可以有权限往你的代码库中提交代码，这是不安全的。这一步操作就是为了解决这个问题。将私钥加密后上传，Travis CI在构建的时候解密。<br>安装travis-ci的命令行工具<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">gem install travis</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>登录Travis CI<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">travis login --auto</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>使用travis命令行工具加密私钥<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">travis encrypt-file ssh_key --add</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="指定SSH设置"><a href="#指定SSH设置" class="headerlink" title="指定SSH设置"></a>指定SSH设置</h2>
<p>在根目录下新建文件<code>ssh_config</code>,内容见我的设置,我同时设置了两个page服务。<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">Host github.com&#10;  User git&#10;  StrictHostKeyChecking no&#10;  IdentityFile ~/.ssh/id_rsa&#10;  IdentitiesOnly yes&#10;&#10;Host git.coding.net&#10;  User git&#10;  StrictHostKeyChecking no&#10;  IdentityFile ~/.ssh/id_rsa&#10;  IdentitiesOnly yes</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="travis-CI解密配置"><a href="#travis-CI解密配置" class="headerlink" title="travis CI解密配置"></a>travis CI解密配置</h2>
<p>这部分内容需要配置在<code>.travis.yml</code>里,注意修改秘钥</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">- openssl aes-256-cbc -K $encrypted_26b4962af0e7_key -iv $encrypted_26b4962af0e7_iv&#10;  -in id_rsa.enc -out ~/.ssh/id_rsa -d</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h1 id="我的-travis-yml配置"><a href="#我的-travis-yml配置" class="headerlink" title="我的.travis.yml配置"></a>我的<code>.travis.yml</code>配置</h1>
<p>上面的描述如果有不明白的地方直接查看我这份完整版的配置文件，拿去修改就可以直接使用。</p>
<figure class="highlight plain">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">language: node_js&#10;&#10;node_js:&#10;- &#39;4.1&#39;&#10;&#10;before_install:&#10;- openssl aes-256-cbc -K $encrypted_26b4962af0e7_key -iv $encrypted_26b4962af0e7_iv&#10;  -in id_rsa.enc -out ~/.ssh/id_rsa -d&#10;- chmod 600 ~/.ssh/id_rsa&#10;- eval $(ssh-agent)&#10;- ssh-add ~/.ssh/id_rsa&#10;- cp ssh_config ~/.ssh/config&#10;- git config --global user.name &#34;pangjian&#34;&#10;- git config --global user.email &#34;pangjian1010@gmail.com&#34;&#10;&#10;install:&#10;- npm install hexo-cli -g&#10;- npm install&#10;&#10;script:&#10;- hexo -version&#10;- hexo clean&#10;- hexo g&#10;- hexo deploy</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>EOF<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2016/05/25/travis-ci-hexo/</p><p>访问原文「<a href='http://www.pangjian.me/2016/05/25/travis-ci-hexo/'>使用travis-ci持续集成Hexo静态博客</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> travis-ci </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器缓存知识归纳]]></title>
      <url>http://www.pangjian.me/2016/03/05/web-cache-detail/</url>
      <content type="html"><![CDATA[<p>写在开头：这篇文章是打算分享到单位内部的材料。归纳浏览器缓存也是对一个生产问题的分析总结出来的。这片文章经过脱敏以后发表到个人博客上面吧。</p>
<p>浏览器缓存（Browser Catching）是为了节约网络的资源加速浏览，浏览器在用户磁盘上对最近请求过的文档进行存储，当访问者再次请求这个页面时，浏览器就可以从本地磁盘显示文档，这样就可以加速页面的阅览。 —-摘自《百度百科》</p>
<p>浏览器缓存是提升网页性能的一大利器，但是，也是一把双刃剑。利用的好网页的性能会有大幅度提升，服务器的压力也会减小。利用的不好，也会遇到很多的问题。本文结合浏览器缓存的知识，结合真实案例进行分析，希望对读者有所帮助。<br>
  <a id="more"></a>
</p>
<h1 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h1>
<p>浏览器缓存分为强缓存和协商缓存，浏览器加载一个页面的简单流程如下：</p>
<ol>
  <li>浏览器先根据这个资源的http头信息来判断是否命中强缓存。如果命中则直接加在缓存中的资源，并不会将请求发送到服务器。</li>
  <li>如果未命中强缓存，则浏览器会将资源加载请求发送到服务器。服务器来判断浏览器本地缓存是否失效。若可以使用，则服务器并不会返回资源信息，浏览器继续从缓存加载资源。</li>
  <li>如果未命中协商缓存，则服务器会将完整的资源返回给浏览器，浏览器加载新资源，并更新缓存。
    <h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1>命中强缓存时，浏览器并不会将请求发送给服务器。在Chrome的开发者工具中看到http的返回码是200，但是在Size列会显示为(from cache)。<br><img src="/resources/web-cache-detail/cache1.png" alt="强缓存"><br>强缓存是利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间。
    <h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2>该字段会返回一个时间，比如Expires:Thu,31 Dec 2037 23:59:59 GMT。这个时间代表着这个资源的失效时间，也就是说在2037年12月31日23点59分59秒之前都是有效的，即命中缓存。这种方式有一个明显的缺点，由于失效时间是一个绝对时间，所以当客户端本地时间被修改以后，服务器与客户端时间偏差变大以后，就会导致缓存混乱。于是发展出了Cache-Control。
      <h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2>Cache-Control是一个相对时间，例如Cache-Control:3600，代表着资源的有效期是3600秒。由于是相对时间，并且都是与客户端时间比较，所以服务器与客户端时间偏差也不会导致问题。<br>Cache-Control与Expires可以在服务端配置同时启用或者启用任意一个，同时启用的时候Cache-Control优先级高。</li>
</ol>
<h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1>
<p>若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。</p>
<h2 id="Last-Modify-If-Modify-Since"><a href="#Last-Modify-If-Modify-Since" class="headerlink" title="Last-Modify/If-Modify-Since"></a>Last-Modify/If-Modify-Since</h2>
<p>浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间，例如Last-Modify: Thu,31 Dec 2037 23:59:59 GMT。<br><img src="/resources/web-cache-detail/last-modify.png" alt="Last-Modify"><br>当浏览器再次请求该资源时，上送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。<br>
  <img src="/resources/web-cache-detail/if-modify-since.png" alt="If-Modify-Since"><br>如果命中缓存，则返回http304，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match。</p>
<h2 id="ETag-If-None-Match"><a href="#ETag-If-None-Match" class="headerlink" title="ETag/If-None-Match"></a>ETag/If-None-Match</h2>
<p>与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个校验码（ETag: entity tag）。ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。服务器根据浏览器上送的If-None-Match值来判断是否命中缓存。<br><img src="/resources/web-cache-detail/etag.png" alt="ETag"></p>
<h2 id="ETag扩展说明"><a href="#ETag扩展说明" class="headerlink" title="* ETag扩展说明"></a>* ETag扩展说明</h2>
<p>我们对ETag寄予厚望，希望它对于每一个url生成唯一的值，资源变化时ETag也发生变化。神秘的Etag是如何生成的呢？以Apache为例，ETag生成靠以下几种因子</p>
<ol>
  <li>文件的i-node编号，此i-node非彼iNode。是Linux/Unix用来识别文件的编号。是的，识别文件用的不是文件名。使用命令’ls –I’可以看到。</li>
  <li>文件最后修改时间</li>
  <li>文件大小<br>生成Etag的时候，可以使用其中一种或几种因子，使用抗碰撞散列函数来生成。所以，理论上ETag也是会重复的，只是概率小到可以忽略。
    <h1 id="生产问题分析"><a href="#生产问题分析" class="headerlink" title="生产问题分析"></a>生产问题分析</h1>背景：某次投产，某系统投产后由于强缓存设置时间不恰当导致变更的功能没有体现。后来通过变更文件路径强行解决问题。<br>变更上下文根，导致URL变化一定可以解决问题。但我们不可能每一次都这么做；还有，在浏览器端关闭缓存、或者清除缓存后再继续浏览、同时使用Ctrl+F5刷新，也可以解决问题，但是我们也不可能让每一个客户在投产后都做一次这个操作。<br>那我们怎么办呢？从问题原因来看，是将经常变化的资源缓存时间设置的过长导致的。理论上来讲，只要正确划分经常变化资源与不经常变化资源就可以解决问题。但是谁也不能保证不经常变化的资源就一定不会变化。<br>万一不经常变化的资源变更了怎么办呢？在资源请求的URL中增加一个参数，比如：css/main.css?v=20160105。这个参数是一个版本号，客户化在js代码中，每一次投产的时候变更一下，当这个参数变化的时候，强缓存都会失效并重新加载。这样一来，即使是不常变化的资源，投产以后也需要重新加载。这样就完美的解决了问题。</li>
</ol>
<p>本文参考数篇技术博客、百度百科、维基百科、Apache官方说明以及自己的理解完成，如有不正确的地方欢迎斧正。<br>EOF<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2016/03/05/web-cache-detail/</p><p>访问原文「<a href='http://www.pangjian.me/2016/03/05/web-cache-detail/'>浏览器缓存知识归纳</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2016年，猴年快乐！]]></title>
      <url>http://www.pangjian.me/2016/02/07/happy-new-year-2016/</url>
      <content type="html"><![CDATA[<p>2016年新年，祝愿所有人新年快乐，猴年吉祥。<br>这片文章是【近期想法】主题的第二篇，上一篇有部分内容已经实现了，只是没有来得及写文章。</p>
<h2 id="hexo静态博客的持续集成"><a href="#hexo静态博客的持续集成" class="headerlink" title="hexo静态博客的持续集成"></a>hexo静态博客的持续集成</h2>
<p>其实就是年前那会结合Travis CI的服务给这个博客弄了个自动部署，写完博客只需要提交到github上就行了，不用再自己生成再部署了。算是简单的持续集成吧。弄得时候有些地方折腾了很久，写出来应该很有意思。</p>
<h2 id="Cloud9使用"><a href="#Cloud9使用" class="headerlink" title="Cloud9使用"></a>Cloud9使用</h2>
<p>在折腾Travis CI那会发现的一个神器–<a href="http://c9.io" target="_blank" rel="external">Cloud9</a>。在线IDE，甚至还能集成一套命令行环境，有点像个VPS。</p>
<h2 id="类似Firebase的自建版本-END-js"><a href="#类似Firebase的自建版本-END-js" class="headerlink" title="类似Firebase的自建版本-END.js"></a>类似Firebase的自建版本-END.js</h2>
<p>之前查Firebase资料的时候搜到的，一个可以自己搭建的Firebase实时框架。但是跑不起来，跟作者联系后，作者已经很久不维护，以后也不会维护了。自己Fork了一下，准备修修补补自己维护一套。</p>
<h2 id="将Firebase服务换成WildDog"><a href="#将Firebase服务换成WildDog" class="headerlink" title="将Firebase服务换成WildDog"></a>将Firebase服务换成WildDog</h2>
<p>国内访问Firebase还是太慢，准备换成国内的类似服务。</p>
<h2 id="将多说换成Disquse"><a href="#将多说换成Disquse" class="headerlink" title="将多说换成Disquse"></a>将多说换成Disquse</h2>
<span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2016/02/07/happy-new-year-2016/</p><p>访问原文「<a href='http://www.pangjian.me/2016/02/07/happy-new-year-2016/'>2016年，猴年快乐！</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
]]></content>
      
        
        <tags>
            
            <tag> notion </tag>
            
            <tag> 生活 </tag>
            
            <tag> 近期想法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我遇到一个Bug，金额大于一千万就报错]]></title>
      <url>http://www.pangjian.me/2016/01/13/a-strange-bug/</url>
      <content type="html"><![CDATA[<p>这是一个在测试环境发现的一个BUG，感觉很有趣，便写出来分享一下。本文的灵感以及标题都来自于《我遇到一个BUG，每逢周三就崩溃》。<br>我在银行做系统开发，“金额”基本上是最常见的字段，也是最不能出错的字段了。每一个错误都代表着实打实的资金损失，无论是客户的还是银行的。所以，作为开发人员，对这个字段也相对敏感一些。金额这个字段的规则也相对其他字段更复杂一些。举个例子来说，金额是一个数字，可以是这样12；当然也有小数点的情况，比如这样12.34；人们还有这样的习惯，每隔3位有一个逗号分隔符，比如这样1,000.23。可是一千万是个什么特殊情况，为什么会有问题呢？<br>
  <a id="more"></a><br>目前系统为了校验前端上送的数据，有一套统一的校验机制。大概过程就是，先使用jackson框架将前端上送的JSON数据进行解析，然后根据这个字段配置的正则表达式进行校验，校验不通过，就会报错。<br>这是一个工作日，在我们内部通讯工具上弹出来一个同事的窗口。“我们有一个交易上送金额，80099690.89元，校验就报错，但是8009969.89元校验就不报错。”我见到这个问题后，第一反应是：“怎么可能，这个校验规则在生产环境运行了那么久都没有出错，怎么会突然有问题呢？会不会是哪里搞错了？”然后，这位同事又发来“前端上送的JSON报文中，金额使用的数字类型<code>amount:80099690.89</code>,但我们平时都上送的字符串类型<code>amount:&#39;80,099,690.89&#39;</code>”。于是，我开始怀疑那个正则表达式是否正确，还在埋怨是谁写的正则，居然要求必须有逗号分隔符的时候，我看到了这正则：<code>^(\d*|\d{1,3}(,\d{3})*)(\.\d{1,2})?</code>。居然是对的！完美的考虑了带逗号和不带逗号的场景。这时候，这位同事又发来消息“把金额按string上送就不报错了<code>amount:&#39;80099690.89&#39;</code>”<br>WTF？！下面这个表情就是我当时的表情。<br>
  <img src="/resources/a-strange-bug/WTF.jpg" alt="WTF"><br>我们知道，在JavaScript中，<code>string</code>和<code>number</code>是可以随时互转的，难道<code>amount:80099690.89</code>和<code>amount:&#39;80099690.89&#39;</code>上送到后端会有不同的逻辑？几千万大小的数字也没有超过精度呀。<br>于是我开始看这篇文章开头提到的那个字段校验公共机制，先使用Jackson解析，然后再利用正则表达式校验。难道是Jackson有问题？看过官方文档，Jackson会将<code>number</code>默认解析成Java的<code>Double</code>型，<code>string</code>则转换为Java的<code>String</code>型，而<code>Double</code>在进行正则校验之前需要先转换为<code>String</code>。<br>
    <figure class="highlight java">
      <table>
        <tr>
          <td class="code">
            <pre><span class="line">Double amount1 = <span class="keyword">new</span> Double(<span class="string">"80099690.89"</span>);</span><br><span class="line">Double amount2 = <span class="keyword">new</span> Double(<span class="string">"8009969.89"</span>);</span><br><span class="line">System.out.print(<span class="string">"amount1 = "</span> + amount1.toString());</span><br><span class="line">System.out.print(<span class="string">"amount2 = "</span> + amount2.toString());</span><br></pre>
          </td>
        </tr>
      </table>
      </figure>
</p>
<p>打印结果为：<br>
  <figure class="highlight plain">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">amount1 = 8.009969089E7&#10;amount2 = 8009969.89</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>相信大家已经看出来了，原来是这样！Java里<code>Double</code>的<code>toString</code>方法当大于7位数的时候会取科学计数法。所以科学计数法的结果是无法匹配这个正则的<code>^(\d*|\d{1,3}(,\d{3})*)(\.\d{1,2})?</code>！<br>从那以后，我终于明白编码规范中为什么要求前端都是用<code>string</code>类型了。我还专门看了接口文档，将类型都调整为了<code>string</code>。<br>其实无论一个bug看上去多么随机和不可思议，如果你挖的足够深的话，总能找到一个符合逻辑的解释，极少有真的“不相关”的错误，几乎都是你自己的错。这就是为什么我微博的简介里会写这么一句话“电脑确实比人靠谱，你和他们打交道时一旦有问题，肯定是你的问题。不像人，即使他们有问题也不轻易承认。”</p>
<p>写在最后：文中提到的那位同事，现在已经去新的岗位提升自己去了，写这篇文章也算纪念一下我们一起共事的时光。^_^~<br>EOF<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2016/01/13/a-strange-bug/</p><p>访问原文「<a href='http://www.pangjian.me/2016/01/13/a-strange-bug/'>我遇到一个Bug，金额大于一千万就报错</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> jackson </tag>
            
            <tag> java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Pjax优化你的网站]]></title>
      <url>http://www.pangjian.me/2015/12/03/pjax-your-blog/</url>
      <content type="html"><![CDATA[<p>Ajax（Asynchronous Javascript and XML）的魅力在于它的每一个成员都不是新技术，经过奇妙的结合却掀起了WEB2.0的革命。<code>Pjax</code>是<code>pushState</code>和<code>ajax</code>的封装，同样每一个都算不上新技术，结合起来却有着神奇的效果。</p>
<a id="more"></a>
<p>前两天在闲逛别人博客的时候，无意间发现了有个人的博客访问速度极快，于是乎好奇研究了一下。在查看代码的时候发现了一个<code>jquery.pjax.min.js</code>。上网查了查资料，这确实是速度快的原因。<br><code>Pjax</code>的主要原理是利用<code>ajax</code>异步请求页面并局部刷新，利用<code>pushState</code>修改url和history，这样就既拥有了<code>ajax</code>局部刷新的优势，同时也避免了只利用<code>ajax</code>的单页面应用url不会变化，不利于SEO，还避免了浏览器的前进后退也失效的问题。
  <a href="http://www.github.io" target="_blank" rel="external">github</a>、Google+都在使用这样的技术。除了以上的优点以外，页面切换浏览器不会白屏，还能添加自己的过度动画这点也着实很有吸引力。非常适用于静态博客这种每次页面切换基本只有主体内容会变化的情况。</p>
<p>本文的内容旨在记录本博客引入pjax的过程，效果可以参考<a href="http://www.pangjian.info" target="_blank" rel="external">本博客</a>。本文讲解的引入过程特指jQuery插件版，可以查看github上的<a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="external">jquery-pjax</a>。</p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1>
<p>不看广告，先看疗效。引入pjax前切换一次页面的请求<br><img src="/resources/using-pjax/pajax_before.png" alt="引入pjax前"></p>
<p>引入pjax后…<br><img src="/resources/using-pjax/pjax_after.png" alt="引入pjax后"><br>效果还是很明显的，请求减少到了3次，大量已经引入的资源文件由于没有刷新，没有重复请求。速度也大大提升了。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1>
<p>非常简单，只需要引入jQuery和jquery-pjax的js即可。这里不再赘述。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1>
<figure class="highlight javascript">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$(<span class="built_in">document</span>).pjax(selector, [container], options)</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<ul>
  <li><code>selector</code>是一个选择器，用来代理点击事件，触发pjax。</li>
  <li><code>container</code>是pjax后需要被替换的部分</li>
  <li><code>options</code>是参数
    <h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2>参数中支持设置超时时间，http请求方式等，这里只介绍两个我用到的。其他参数可以在github上<a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="external">jquery-pjax</a>查看。
    <h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><code>timeout</code></h3><code>timeout</code>是pjax的超时事件，timeout时间以后就会触发一次完整的页面刷新。默认的650ms太短了，经常会触发刷新。所以我把它设的大了一点。
    <h3 id="fragment"><a href="#fragment" class="headerlink" title="fragment"></a><code>fragment</code></h3><code>fragment</code>，如果你的网站也没有后端支持，每次pjax请求仍然会返回完整的页面的话你就需要这个参数了。他同样是一个选择器，在完整的返回页面中选出需要替换的内容，将不需要刷新的部分过滤掉。也就是说，新返回的页面的<code>fragment</code>部分会替换掉当前页面的<code>container</code>部分。</li>
</ul>
<p>下段代码是这个博客的使用片段：<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$(<span class="built_in">document</span>).pjax(<span class="string">'a'</span>, <span class="string">'#main'</span>, &#123; fragment: (<span class="string">'#main'</span>), timeout: <span class="number">10000</span> &#125;);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2>
<p>pjax支持事件回调函数，用来定制一些动作。这里也只介绍这个博客在使用的，其他可以在github上<a href="https://github.com/defunkt/jquery-pjax" target="_blank" rel="external">jquery-pjax</a>查看。</p>
<h3 id="pjax-click"><a href="#pjax-click" class="headerlink" title="pjax:click"></a><code>pjax:click</code></h3>
<p>当<code>selector</code>被点击时触发，我将开始转场动画的方法<code>NProgress.start()</code>放到了这个事件上。</p>
<h3 id="pjax-start"><a href="#pjax-start" class="headerlink" title="pjax:start"></a><code>pjax:start</code></h3>
<p>顾名思义pjax开始事件</p>
<h3 id="pjax-end"><a href="#pjax-end" class="headerlink" title="pjax:end"></a><code>pjax:end</code></h3>
<p>顾名思义pjax结束事件，我将动画的结束方法放到了这个事件上。<code>NProgress.done()</code>,同时，由于页面上的局部刷新了，原先绑定在这部分内容上的事件都失效了，我也在这个事件上增加了一个方法，重新绑定了一些事件，很重要的部分就是将多说显示出来，另外替换博客访问量的计数器，访问计数器数值也应该加1。</p>
<h1 id="原理简述"><a href="#原理简述" class="headerlink" title="原理简述"></a>原理简述</h1>
<h3 id="pushState"><a href="#pushState" class="headerlink" title="pushState"></a><code>pushState</code></h3>
<p><code>pushState</code>是HTML的新增Api。用来改变当前页面的URL而不刷新页面。使用方法如下：<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="built_in">window</span>.history.pushState(state, title, url);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p><code>state</code>用来配合<code>popstate</code>创建历史，<code>title</code>为标题，<code>url</code>为要替换的地址。此处应注意两点，<code>pushState</code>并不能改变标题，<code>url</code>只能替换同域名的url。</p>
<h3 id="ajax与pushState结合"><a href="#ajax与pushState结合" class="headerlink" title="ajax与pushState结合"></a><code>ajax</code>与<code>pushState</code>结合</h3>
<p>请参考下面伪代码,它实现了简单的<code>pjax</code><br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$(<span class="string">"a"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  <span class="keyword">var</span> target_url = $(<span class="keyword">this</span>).attr(<span class="string">'href'</span>);</span><br><span class="line">  loadTarget(target_url,<span class="function"><span class="keyword">function</span>(<span class="params">ret</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">document</span>.title=ret.title; <span class="comment">// 更换新的页面标题</span></span><br><span class="line">   <span class="keyword">if</span>(history.pushState)&#123;</span><br><span class="line">     <span class="keyword">var</span> state = (&#123;</span><br><span class="line">       url:target_url,</span><br><span class="line">       title:ret.title</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="built_in">window</span>.history.pushState(state, ret.title, target_url)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;);<span class="comment">//使用ajax获取目标页面，成功调用回调函数</span></span><br><span class="line">&#125;);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1>
<p>这个博客的转场动画使用的<a href="http://ricostacruz.com/nprogress/" target="_blank" rel="external">NProgress</a>。类似Youtube上的红色激光。使用起来也很加单。我自己玩了很久…<br><img src="/resources/using-pjax/NProgress.png" alt="NProgress"><br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/12/03/pjax-your-blog/</p><p>访问原文「<a href='http://www.pangjian.me/2015/12/03/pjax-your-blog/'>使用Pjax优化你的网站</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> nprogress </tag>
            
            <tag> pjax </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[javascript前后端代码复用-browserify]]></title>
      <url>http://www.pangjian.me/2015/11/18/node-on-browser-browserify/</url>
      <content type="html"><![CDATA[<p>Nodejs将javascript带上了一个新的高度，让之运行于浏览器端的javascript可以运行在服务器端。但是Nodejs遵循Commonjs规范，不能直接运行在浏览器端。虽然是同一种语言，但是前后端有着自己的库，不能复用真是一种浪费。<br>这时候一个神器出现了，<a href="http://browserify.org/" target="_blank" rel="external">Browserify</a>。通过预编译，可以将Commonjs规范的后端Nodejs代码直接可以运行在浏览器端。打通了端后端代码复用的壁垒，为nodejs程序开辟了一片新天地。</p>
<a id="more"></a>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1>
<p><a href="http://www.pangjian.info/2015/09/15/recent-thinking-2015-09/" target="_blank" rel="external">前面一片博客</a>提到了我需要一种前端解析Velocity模板的方法，终于找到一个好的方法。苦于代码是基于Nodejs的，readme中提示可以使用spm打包后使用，试了好多次都没有成功。无意间在知乎上发现了Browserify。顺利满足需求，下一篇博客就会写这部分内容。</p>
<h1 id="Browserify安装"><a href="#Browserify安装" class="headerlink" title="Browserify安装"></a>Browserify安装</h1>
<p>就像封面图片上那样，使用npm全局安装。</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ npm install -g browserify</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h1 id="Browser使用"><a href="#Browser使用" class="headerlink" title="Browser使用"></a>Browser使用</h1>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2>
<p>官方说明如下，部分选项做了翻译<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">Usage: browserify [entry files] &#123;OPTIONS&#125;&#10;&#10;Standard Options:&#10;&#10;    --outfile, -o  browserify&#26085;&#24535;&#25171;&#21360;&#21040;&#25991;&#20214;&#10;    --require, -r  &#32465;&#23450;&#27169;&#22359;&#21517;&#25110;&#25991;&#20214;&#65292;&#29992;&#36887;&#21495;&#20998;&#38548;&#10;    --entry, -e  &#24212;&#29992;&#31243;&#24207;&#30340;&#20837;&#21475;&#10;    --ignore, -i  Replace a file with an empty stub. Files can be globs.&#10;    --exclude, -u  Omit a file from the output bundle. Files can be globs.&#20174;&#20854;&#20182;&#32465;&#23450;&#24341;&#20837;&#25991;&#20214;&#10;    --external, -x  Reference a file from another bundle. Files can be globs.&#10;    --transform, -t  Use a transform module on top-level files.&#10;    --command, -c  Use a transform command on top-level files.&#10;    --standalone -s  Generate a UMD bundle for the supplied export name.&#10;                   This bundle works with other module systems and sets the name&#10;                   given as a window global if no module system is found.&#10;    --debug -d  Enable source maps that allow you to debug your files separately.&#10;              &#28608;&#27963;source maps&#35843;&#35797;&#25991;&#20214;&#10;    --help, -h  Show this message &#24110;&#21161;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2>
<p>编写Nodejs服务端脚本，outputName.js，index.js<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello '</span>+name);</span><br><span class="line">&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<figure class="highlight javascript">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line"><span class="keyword">var</span> outputname = <span class="built_in">require</span>(<span class="string">'./outputName.js'</span>);</span><br><span class="line">outputname(<span class="string">'pangjian'</span>);</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>在Nodejs环境下运行结果如下：<br><img src="/resources/node-on-browser-browserify/nodeResult.png" alt="Nodejs环境下运行结果"></p>
<p>使用browserify预编译一下<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">$ browserify index.js &#62; bundle.js</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>之后你就可以直接在浏览器中这样使用：<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"bundle.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>查看浏览器端运行结果：<br><img src="/resources/node-on-browser-browserify/browserResult.png" alt="浏览器端运行结果"></p>
<p>当然，你肯定不能满足于将所有脚本全部打包成一个js文件，仅仅在<code>script</code>标签上引用进来。你需要的也许是将某个模块打包，然后在浏览器的js中使用<code>require(module)</code>来调用这个模块，这也正是我需要的。那么你需要在执行预编译的时候加上<code>-r</code>参数即可。</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">$ browserify -r outputName.js:ouputname &#62; bundle.js</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>冒号后面是你指定的模块名称，这样你就可以在script标签中这么使用：<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="keyword">var</span> outputname = <span class="built_in">require</span>(<span class="string">'ouputname'</span>);</span><br><span class="line">	outputname(<span class="string">'pangjian'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>好了，大功告成，接下来就是发挥你想象的时间。<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/11/18/node-on-browser-browserify/</p><p>访问原文「<a href='http://www.pangjian.me/2015/11/18/node-on-browser-browserify/'>javascript前后端代码复用-browserify</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> Nodejs </tag>
            
            <tag> browserify </tag>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Jackson中的那些坑]]></title>
      <url>http://www.pangjian.me/2015/10/30/json-and-java-object2/</url>
      <content type="html"><![CDATA[<h1 id="不符合驼峰规范的变量"><a href="#不符合驼峰规范的变量" class="headerlink" title="不符合驼峰规范的变量"></a>不符合驼峰规范的变量</h1>
<p>“驼峰命名法”请自行百度。简单的来说就是变量的第一个单词以小写字母开始其他单词首字母大写，或者全部单词首字母都大写，分别称为“小驼峰”和“大驼峰”<br>
  <a id="more"></a><br>比如一个符合驼峰规范命名的实体：<br>
  <figure class="highlight java">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    String beFlag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBeFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeFlag</span><span class="params">(String beFlag)</span> </span>&#123;</span><br><span class="line">        beFlag = beFlag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>转化的JSON为:<br>
  <figure class="highlight json">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;"<span class="attribute">beFlag</span>":<span class="value"><span class="literal">null</span></span>&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>前段时间走查代码时发现一个问题，实体中有一个字段为ECash。驼峰规范中并没有详细说明这种单词只有一个字母的变量是否符合驼峰规范。当遇到这种变量时，转化的JSON发送了问题，我们的预期应该是这样的<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;“eCash”:null&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>但实际情况是这样的<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;“ecash”:null&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>没错，字母全部被小写了。这可是个大问题，接口文档按经验肯定是错的。<br>如何解决呢？<br>当然是尽量按照驼峰规范命名变量，如果不行，那就得使用注解的方式。<br>Jackson提供了” JsonProperty”注解方式，使用如下代码<br>
  <figure class="highlight java">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@JsonProperty</span></span><br><span class="line">    String ECash;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getECash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ECash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setECash</span><span class="params">(String eCash)</span> </span>&#123;</span><br><span class="line">        ECash = eCash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>得到的JSON结果为<br>
  <figure class="highlight json">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;"<span class="attribute">ECash</span>":<span class="value"><span class="literal">null</span></span>,"<span class="attribute">ecash</span>":<span class="value"><span class="literal">null</span></span>&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>虽然我们希望的”ECash“来了，但是之前全小写的还存在。这是因为ECash的get方法，使用@JsonIgnore即可解决。代码变成这样:<br>
  <figure class="highlight java">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@JsonProperty</span></span><br><span class="line">    String ECash;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JsonIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getECash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ECash;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setECash</span><span class="params">(String eCash)</span> </span>&#123;</span><br><span class="line">        ECash = eCash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>得到的JSON结果为：<br>
  <figure class="highlight json">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;"<span class="attribute">ECash</span>":<span class="value"><span class="literal">null</span></span>&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>至此，问题解决了。除此之外，JsonProperty还可以指定JSON中的值，比如这样：<br>
  <figure class="highlight java">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Entity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@JsonProperty</span>(<span class="string">"eCash"</span>)</span><br><span class="line">    String ECash;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JsonIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getECash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ECash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setECash</span><span class="params">(String eCash)</span> </span>&#123;</span><br><span class="line">        ECash = eCash;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>即指定JSON的结果为小驼峰模式。<br>
  <figure class="highlight json">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;"<span class="attribute">eCash</span>":<span class="value"><span class="literal">null</span></span>&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>举一反三，JsonProperty的使用场景还有很多，除了解决这个“坑”以外。还可以直接用来转换类UNIX习惯的下划线间隔的变量转化为驼峰规范。<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/10/30/json-and-java-object2/</p><p>访问原文「<a href='http://www.pangjian.me/2015/10/30/json-and-java-object2/'>Jackson中的那些坑</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> jackson </tag>
            
            <tag> java </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[近期想法汇总2015年9月]]></title>
      <url>http://www.pangjian.me/2015/09/15/recent-thinking-2015-09/</url>
      <content type="html"><![CDATA[<p>打算新开一类主题，主要用来记录近期的一些想法，有想好了要做的事情，也有要做但是还没有思路的事情。类似LifeHacker那样，不仅仅有编程相关。可以有技术、科技、设计、生活想法等等，如果时机成熟，这一个个的点子实践以后会形成一片单独的文章，如果我一直没有想法，看到这篇文章的人也可以在评论里帮我出出主意。这篇文字是第一次尝试。<br>
  <a id="more"></a>
</p>
<h2 id="接口接入控制，以及如何防止恶意、伪造接入"><a href="#接口接入控制，以及如何防止恶意、伪造接入" class="headerlink" title="接口接入控制，以及如何防止恶意、伪造接入"></a>接口接入控制，以及如何防止恶意、伪造接入</h2>
<p>这个想法来源于工作，一个纯前后端分离的项目，后端仅提供基于JSON的数据接口，不处理页面展现，前面接入了多种终端，包括浏览器、手机客户端、电视上的客户端等等…<br>随着需求的扩张，需要一种控制机制根据不同的终端类型来控制是否可以接入。说到控制，倒是不难，不过，有没有什么办法来识别终端类型，并且很难伪造呢？</p>
<h2 id="简单Velocity语法检查器，最好是仅基于JavaScript的"><a href="#简单Velocity语法检查器，最好是仅基于JavaScript的" class="headerlink" title="简单Velocity语法检查器，最好是仅基于JavaScript的"></a>简单Velocity语法检查器，最好是仅基于JavaScript的</h2>
<p>这个想法也来源于工作，由于种种原因，需要非技术人员来维护一套Velocity模板，由于没有基础，所以需要一种技术手段来防止出错。由于维护是在一套专门的系统中进行的，首先想到的就是对修改后的模板进行语法检查，避免语法错误。如果是页面上就能检查就更好了。</p>
<p>更新：这么快就找到有人做过这个。<a href="http://ued.taobao.org/blog/2012/11/how-to-realize-a-compiler/" target="_blank" rel="external">如何实现Velocity模板语法解释器</a></p>
<h2 id="如何简单制作一个延时摄影作品"><a href="#如何简单制作一个延时摄影作品" class="headerlink" title="如何简单制作一个延时摄影作品"></a>如何简单制作一个延时摄影作品</h2>
<p>这个月初，请了几天假带着老婆去巴厘岛疯了一圈。鉴于我手机的摄像头坏了，于是带了小蚁运动相机。使用延时摄影功能，拍摄了号称“全球最美十大日落之一”的金巴兰海滩日落。印象中可以用Premiere将多张照片拼接成视频。<br>这里先贴一张<br><img src="/resources/recent-thinking/Jimbaran.png" alt="金巴兰海滩日落"></p>
<h2 id="基于NodeJS的前后端分离实践"><a href="#基于NodeJS的前后端分离实践" class="headerlink" title="基于NodeJS的前后端分离实践"></a>基于NodeJS的前后端分离实践</h2>
<p>突然发现自己语文好差，随便写点东西感觉就不通顺^_^<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/09/15/recent-thinking-2015-09/</p><p>访问原文「<a href='http://www.pangjian.me/2015/09/15/recent-thinking-2015-09/'>近期想法汇总2015年9月</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> notion </tag>
            
            <tag> 近期想法 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JSON与Java对象的事]]></title>
      <url>http://www.pangjian.me/2015/09/12/json-and-java-object/</url>
      <content type="html"><![CDATA[<p>很久没有写了，来清理一下杂草。这片文字是团队内其他小伙伴经常混淆的一个知识点，最初的目的是写个东西好让大家用到的时候可查，由于原文涉及公司的一个框架，不便写出来。该框架其实引用的开源框架Jackson，所以本文直接介绍Jackson部分。其实说不上介绍，约等于一个学习笔记。<br>
  <a id="more"></a>
</p>
<h2 id="JSON是什么？"><a href="#JSON是什么？" class="headerlink" title="JSON是什么？"></a>JSON是什么？</h2>
<p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式。它基于JavaScript（Standard ECMA-262 3rd Edition - December 1999）的一个子集。JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C、C++、C#、Java、JavaScript、Perl、Python等）。这些特性使JSON成为理想的数据交换语言。易于人阅读和编写，同时也易于机器解析和生成。</p>
<h3 id="JSON的值可以是"><a href="#JSON的值可以是" class="headerlink" title="JSON的值可以是"></a>JSON的值可以是</h3>
<ul>
  <li>数字number（整数获浮点数）<br><img src="/resources/json-and-java-object/number.PNG" alt="number"></li>
  <li>字符串string（在双引号获单引号中）<br><img src="/resources/json-and-java-object/string.PNG" alt="string"></li>
  <li>逻辑值boolean（true获false）</li>
  <li>数组array（在方括号中）<br><img src="/resources/json-and-java-object/array.PNG" alt="array"></li>
  <li>对象object（在花括号中）<br><img src="/resources/json-and-java-object/object.PNG" alt="object"></li>
  <li>函数function</li>
  <li>null</li>
</ul>
<p>所以说String、BigDecimal、List、Map、Integer都不是JSON的值，这些只是java中的类，在JavaScript中是不存在的。（作为Java开发者，不能手里拿着锤子就看什么都是钉子）</p>
<h2 id="JSON示例"><a href="#JSON示例" class="headerlink" title="JSON示例"></a>JSON示例</h2>
<figure class="highlight javascript">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"number"</span>:<span class="number">1234</span>,</span><br><span class="line">    <span class="string">"number2"</span>:<span class="number">12.34</span>,</span><br><span class="line">    <span class="string">"numString"</span>:<span class="string">"1234"</span>,</span><br><span class="line">    <span class="string">"numString2"</span>:<span class="string">"12.34"</span>,</span><br><span class="line">    <span class="string">"string"</span>:<span class="string">"abc"</span>,</span><br><span class="line">    <span class="string">"object"</span>:&#123;<span class="string">"p1"</span>:<span class="string">"abc"</span>&#125;,</span><br><span class="line">    <span class="string">"array"</span>:[<span class="string">"a"</span>,<span class="string">"b"</span>],</span><br><span class="line">    <span class="string">"boolean"</span>:<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="Jackson"><a href="#Jackson" class="headerlink" title="Jackson"></a>Jackson</h2>
<h2 id="Java与JSON的映射关系（基于Jackson）"><a href="#Java与JSON的映射关系（基于Jackson）" class="headerlink" title="Java与JSON的映射关系（基于Jackson）"></a>Java与JSON的映射关系（基于Jackson）</h2>
<h2 id="代码及运行结果"><a href="#代码及运行结果" class="headerlink" title="代码及运行结果"></a>代码及运行结果</h2>
<ul>
  <li>“number”:1234
    <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/09/12/json-and-java-object/</p><p>访问原文「<a href='http://www.pangjian.me/2015/09/12/json-and-java-object/'>JSON与Java对象的事</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

  </li>
</ul>]]></content>
      
        
        <tags>
            
            <tag> jackson </tag>
            
            <tag> java </tag>
            
            <tag> json </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[升级Hexo2.X到3.0]]></title>
      <url>http://www.pangjian.me/2015/04/11/hexo-update-to-3-0/</url>
      <content type="html"><![CDATA[<p>我一般不想转或者写别人写过的一些东西，但是今天这篇文章算是转的，完全记录了我升级hexo的过程。为什么呢？实在是觊觎了很久了，一直没敢动手，3.0版本可是个大手术，据说好多主题和插件都挂了，现在这个主题我修改了不少，怕万一出个什么问题很麻烦。仅以此文来记录这次没什么意外地升级。</p>
<h2 id="Hexo3-0新特性"><a href="#Hexo3-0新特性" class="headerlink" title="Hexo3.0新特性"></a>Hexo3.0新特性</h2>
<ul>
  <li>新的命令行工具：hexo-cli</li>
  <li>更轻量级的核心模块：generators，deployers和server都从主模块中分离出来了</li>
  <li>新的generator Api</li>
  <li>支持时区</li>
  <li><a href="https://github.com/hexojs/hexo/wiki/Breaking-Changes-in-Hexo-3.0" target="_blank" rel="external">更多</a></li>
</ul>
<a id="more"></a>
<h2 id="下面是操作步骤"><a href="#下面是操作步骤" class="headerlink" title="下面是操作步骤"></a>下面是操作步骤</h2>
<h3 id="更改package-json"><a href="#更改package-json" class="headerlink" title="更改package.json"></a>更改package.json</h3>
<p>给<code>package.json</code>添加<code>hexo</code><br>
  <figure class="highlight json">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">hexo</span>":<span class="value">&#123;</span><br><span class="line">        "<span class="attribute">version</span>":<span class="value"><span class="string">""</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h3>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">hexo clean</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="全局安装hexo-cli"><a href="#全局安装hexo-cli" class="headerlink" title="全局安装hexo-cli"></a>全局安装hexo-cli</h3>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">sudo npm install hexo-cli -g</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3>
<p>新的hexo不安装在全局了<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">npm install hexo --save</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>以下的模块是按需安装</p>
<hr>
<h3 id="安装generators"><a href="#安装generators" class="headerlink" title="安装generators"></a>安装generators</h3>
<p>从插件的名字就拿看出来它是干什么的<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">npm install hexo-generator-index --save&#10;npm install hexo-generator-archive --save&#10;npm install hexo-generator-category --save&#10;npm install hexo-generator-tag --save</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="安装server"><a href="#安装server" class="headerlink" title="安装server"></a>安装server</h3>
<p>这个用于本地调试的server一般人都会装<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">npm install hexo-server --save</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="安装deployers"><a href="#安装deployers" class="headerlink" title="安装deployers"></a>安装deployers</h3>
<p>我是部署在github和gitcafe上的，所以只安装了git的deployer<br>
  <figure class="highlight">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">npm install hexo-deployer-git --save&#10;npm install hexo-deployer-heroku --save&#10;npm install hexo-deployer-rsync --save&#10;npm install hexo-deployer-openshift --save</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="更新插件"><a href="#更新插件" class="headerlink" title="更新插件"></a>更新插件</h3>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">npm install hexo-renderer-marked@0.2 --save&#10;npm install hexo-renderer-stylus@0.2 --save&#10;npm install hexo-generator-feed@1 --save&#10;npm install hexo-generator-sitemap@1 --save</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>
<p>打完收工，看看成果吧</p>
<figure class="highlight">
  <table>
    <tr>
      <td class="code">
        <pre><span class="line">hexo g&#10;hexo server</span><br></pre>
      </td>
    </tr>
  </table>
</figure>
<p>浏览器打开<code>127.0.0.1:4000</code>看看效果<br><img src="/resources/hexo-update-to-3-0/pangjian.info.png" alt="pangjian.info"></p>
<p>还算是顺利，虽然部分国际化内容变成了繁体中文，是因为我没有指定语言的过，写了一个<code>en-US.yml</code>然后在<code>_config.yml</code>中指定语言为<code>en-US</code>。刷新，大功告成。<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/04/11/hexo-update-to-3-0/</p><p>访问原文「<a href='http://www.pangjian.me/2015/04/11/hexo-update-to-3-0/'>升级Hexo2.X到3.0</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用Swiftype为静态博客添加站内搜索]]></title>
      <url>http://www.pangjian.me/2015/03/24/site-search-with-swiftype/</url>
      <content type="html"><![CDATA[<blockquote>
  <p>为网站、App提供站内搜索的Swiftype获1300万美元B轮融资。Swiftype可以为网站及移动App提供内置搜索引擎服务，搜索服务的部署非常简单，只需要插入一行JS代码即可搞定。于Google相比，高度可定制化是它的优势。<br>来自：36Kr</p>
</blockquote>
<a id="more"></a>
<p>之前一直用的默认的百度搜索，由于某种问题一直效果不理想。Google又被墙了（无法访问），也没法使用。在微博上看到文章开头这个新闻，突然有了拿来用的想法。</p>
<h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2>
<p>点击本站右上角的搜索图标，在弹出的模态窗口中输入你想要搜索的内容。怎么样，Swiftype真是“天生异禀，骨骼惊奇”。自动补全、实时展示搜索结果，搜索结果还有缩略图展示。<br>如图：<br><img src="/resources/site-search-with-swiftype/searchresult.PNG" alt="搜索结果"></p>
<h2 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h2>
<h4 id="申请Swiftype账号"><a href="#申请Swiftype账号" class="headerlink" title="申请Swiftype账号"></a>申请Swiftype账号</h4>
<p>进入<a href="https://swiftype.com" target="_blank" rel="external">Swiftype官网</a>，注册一个免费账号。然后按照引导将你的网址输入给Swiftype，Swiftype就会自动抓取站点的所有页面。</p>
<h4 id="将搜索框安装到网站"><a href="#将搜索框安装到网站" class="headerlink" title="将搜索框安装到网站"></a>将搜索框安装到网站</h4>
<p>切换到install标签，如图：<br><img src="/resources/site-search-with-swiftype/install.PNG" alt="install面板"><br>按照你喜欢的方式选择搜索页面出现的方式。我选择的直接将搜索结果展示在本页的模态窗口上。点击获取代码，你会得到一段js代码。将这段代码安装在你网站的任意位置即可，剩下的就交给Swiftype去做吧。它会自动创建一个搜索按钮，点击一下，就能出现搜索页面，动画效果也很漂亮。<br><strong>但是，如果我们不喜欢那个在右下角丑丑的搜索按钮怎么办？</strong><br>因为我的网站有自己的搜索按钮，直接用这个现成的不是很好？我为这个问题可是被折磨了一下午。最后发现解决办法是那么的简单..<br>将你的搜索按钮增加一个<code>class</code>,值为<code>st-search-launcher</code><br>我的代码如下：<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">id</span>=<span class="value">"nav-search-btn"</span> <span class="attribute">class</span>=<span class="value">"nav-icon st-search-launcher"</span> <span class="attribute">title</span>=<span class="value">"Search"</span>&gt;</span><span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
    </figure>
</p>
<p>就这样，自动添加的搜索按钮没有了，点一下网站自己的搜索按钮，弹出了搜索窗口。大功告成！</p>
<h4 id="优化搜索结果"><a href="#优化搜索结果" class="headerlink" title="优化搜索结果"></a>优化搜索结果</h4>
<p>在rankings标签可以对你的搜索结果进行管理。比如排序、删除某些搜索结果、增加一个特定的搜索结果等等，自定义空间很大。<br><img src="/resources/site-search-with-swiftype/manageresult.PNG" alt="管理搜索结果"></p>
<h4 id="为搜索结果添加缩略图"><a href="#为搜索结果添加缩略图" class="headerlink" title="为搜索结果添加缩略图"></a>为搜索结果添加缩略图</h4>
<p>能为搜索结果添加缩略图当然很炫。怎么做呢？也很简单！Swiftype的文档上说只需要在页面的header中添加一个<code>meta</code>标签就可以。<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">property</span>=<span class="value">"st:image"</span> <span class="attribute">content</span>=<span class="value">"图片url"</span>&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>以Hexo为例，在<code>head.ejs</code>中增加这样一段代码<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (<span class="attribute">page.photos</span> &amp;&amp; <span class="attribute">page.photos.length</span>)&#123; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">property</span>=<span class="value">"st:image"</span> <span class="attribute">content</span>=<span class="value">"&lt;%- url_for(page.photos[0]) %&gt;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>意思就是，如果文章中有photos（就是展示在文章头部的fancybox），就在html中添加meta标签，于fancybox使用一样的图片，如果fancybox有多个图片，那么就是用第一张。这样在使用<code>hexo d</code>生成博客的时候，就会自动在每一个包含fancybox的文章页面上加入这个<code>meta</code>标签，Swiftype就会为这片文章的搜索结果显示缩略图。</p>
<p>就这样，你的站内搜索就已经完成。如果有其他更好的玩法，欢迎留言讨论。<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/03/24/site-search-with-swiftype/</p><p>访问原文「<a href='http://www.pangjian.me/2015/03/24/site-search-with-swiftype/'>使用Swiftype为静态博客添加站内搜索</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
            <tag> site search </tag>
            
            <tag> swiftype </tag>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[不用cookie我也能追踪你！]]></title>
      <url>http://www.pangjian.me/2015/03/09/track-u-without-cookie/</url>
      <content type="html"><![CDATA[<p>抱歉起了这么个“吸引人的”标题，但我不是标题党。最近由于工作上的一些事情，涉及到识别、追踪设备的项目来了几个，从一篇论文《The Web Never Forgets》无意间又发现了这个技术。查阅了一些资料。做了个小Demo应用到了本博客上。对！你没听错，本页面在追踪你。不过也没那么可怕。看看本站的Visitor Info模块，它可能在屏幕右侧也可能在最底下。这个模块会知道你是否之前访问过本站，并且结合了上一篇博文<a href="http://pangjian.info/2015/02/27/realtime-count-firebase/" target="_blank" rel="external">基于Firebase的Hexo博客实时访问数统计</a>中提到的访问数统计，做到了记录每一位访问者的访问次数。即使你关闭了cookie。^
  _ ^<br>
  <a id="more"></a>
</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2>
<p>这个技术的原理是这样的，网站使用了一个HTML5的标签<code>canvas</code>。在绘制canvas的时候，不同的机器、平台、浏览器绘制出的图片在哈希层面是不同且独一无二的，利用这个特性可以追踪这个用户。<br>技术原理是这样的，但是为什么每一个设备、浏览器绘制的图像是不同的我不太清楚，有兴趣可以参考文章最后的链接。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2>
<p>首先绘制一个<code>canvas</code><br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line"><span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"><span class="keyword">var</span> txt = <span class="string">'http://pangjian.info'</span>;</span><br><span class="line">ctx.textBaseline = <span class="string">"top"</span>;</span><br><span class="line">ctx.font = <span class="string">"14px 'Arial"</span>;</span><br><span class="line">ctx.textBaseline = <span class="string">"pangjian"</span>;</span><br><span class="line">ctx.fillStyle = <span class="string">"#f60"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">125</span>, <span class="number">1</span>, <span class="number">62</span>, <span class="number">20</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">"#069"</span>;</span><br><span class="line">ctx.fillText(txt, <span class="number">2</span>, <span class="number">15</span>);</span><br><span class="line">ctx.fillStyle = <span class="string">"rgba(102, 204, 0, 0.7)"</span>;</span><br><span class="line">ctx.fillText(txt, <span class="number">4</span>, <span class="number">17</span>);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>然后通过<code>canvas.toDataURL()</code>获取图片的base64编码，png图片被划分成很多块，每块的最后32bit数据是crc校验值，提取出这个值就可以用来当做浏览器指纹。<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">var</span> b64 = canvas.toDataURL().replace(<span class="string">"data:image/png;base64,"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="keyword">var</span> bin = atob(b64);</span><br><span class="line"><span class="keyword">var</span> crc = _t.bin2hex(bin.slice(-<span class="number">16</span>, -<span class="number">12</span>));</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>字节转换成16进制方法<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">bin2hex: <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i, l, o = <span class="string">''</span>,</span><br><span class="line">        n;</span><br><span class="line">    s += <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, l = s.length; i &lt; l; i++) &#123;</span><br><span class="line">        n = s.charCodeAt(i).toString(<span class="number">16</span>);</span><br><span class="line">        o += n.length &lt; <span class="number">2</span> ? <span class="string">'0'</span> + n : n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>当然你查看本页的源代码可以看到一个文件-<code>canvasFringerprint.js</code>。那是完整代码。<br>我提取出这个指纹以后，在Firebase上为每一个指纹设置了一个计数器，这样就实现了为每一位访问者记录访问次数。<br>效果如下：<br><img src="/resources/track-u-without-cookie/visitor_counter.png" alt="visitor counter"><br>你可以试试开启浏览器的隐身模式，或者删除全部cookie。再刷新一下这个页面，看看是不是他还记得你？</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2>
<p><a href="https://securehomes.esat.kuleuven.be/~gacar/persistent/the_web_never_forgets.pdf" target="_blank" rel="external">https://securehomes.esat.kuleuven.be/~gacar/persistent/the_web_never_forgets.pdf</a><br><a href="https://www.browserleaks.com/canvas#how-does-it-work" target="_blank" rel="external">https://www.browserleaks.com/canvas#how-does-it-work</a><br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/03/09/track-u-without-cookie/</p><p>访问原文「<a href='http://www.pangjian.me/2015/03/09/track-u-without-cookie/'>不用cookie我也能追踪你！</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> canvas </tag>
            
            <tag> cookie </tag>
            
            <tag> html5 </tag>
            
            <tag> javascript </tag>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[基于Firebase的Hexo博客实时访问数统计]]></title>
      <url>http://www.pangjian.me/2015/02/27/realtime-count-firebase/</url>
      <content type="html"><![CDATA[<p>本来想写一个HEXO的搭建过程的，但是在搜索引擎上一搜一大把教程。看到有人评论：“你写这个跟HEXO官方的教程比好在哪？”仔细想想，说的极好。索性也就不写这个人家已经写烂了的东西了。附一个<a href="http://hexo.io/docs/" target="_blank" rel="external">官方教程链接</a>。其实在搭建过程中还参考了一个很全面很详细的博客，也附上链接吧，<a href="http://ibruce.info/2013/11/22/hexo-your-blog/" target="_blank" rel="external">ibruce不如</a>。<br>对于像HEXO这种静态博客来讲，想要做到一些动态的功能就必须得靠第三方支持，比如评论可以使用多说、Disqus。虽然我的blog的访问人数少的可怜，但是我还是希望知道有多少访问量的。于是乎发现了FireBase这个神奇的东西，它是一个制作实时应用的框架，用它来统计访问量绰绰有余啦。它可以做到的就像本博客下面的一样，你可以尝试开启两个本博客窗口，然后刷新其中一个，看看另外一个页面，是不是很神奇？另一个页面的访问量也实时增加了！</p>
<a id="more"></a>
<h2 id="注册Firebase账号"><a href="#注册Firebase账号" class="headerlink" title="注册Firebase账号"></a>注册Firebase账号</h2>
<p>在<a href="http://www.firebase.com" target="_blank" rel="external">Firebase官网</a>注册一个新用户<br><img src="/resources/realtime-count-firebase/signup.PNG" alt="Sign Up"></p>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2>
<p>注册成功以后就可以创建一个应用了<br><img src="/resources/realtime-count-firebase/createApp.PNG" alt="create app"></p>
<h2 id="Firebase基本用法"><a href="#Firebase基本用法" class="headerlink" title="Firebase基本用法"></a>Firebase基本用法</h2>
<p>Firebase使用JSON存储数据，但是Firebase不支持Arrays数组，它会将数组转换成一个Object对象来存储，就像这样。<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>会被转换成这样存储<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line">&#123;<span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, <span class="number">2</span>: <span class="string">'c'</span>, <span class="number">3</span>: <span class="string">'d'</span>, <span class="number">4</span>: <span class="string">'e'</span>&#125;</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="存储数据"><a href="#存储数据" class="headerlink" title="存储数据"></a>存储数据</h3>
<h4 id="set"><a href="#set" class="headerlink" title="set()"></a><code>set()</code></h4>
<p><code>set()</code>方法调用若原先没有值则会新增，若原先有值，会覆盖原有的结构替换成这次的内容包括子节点！</p>
<h4 id="update"><a href="#update" class="headerlink" title="update()"></a><code>update()</code></h4>
<p><code>update()</code>可以更新一个已经存在的值，并且不会覆盖其他内容。</p>
<h4 id="transaction"><a href="#transaction" class="headerlink" title="transaction()"></a><code>transaction()</code></h4>
<p><code>transaction()</code>就是本文用来统计访问量的方法。支持在原有值得基础上进行修改，它的参数是一个回调函数，用来处理原有的值使其变成新的值。下面是官方给的例子，就是用来统计访问量的。<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">var</span> upvotesRef = <span class="keyword">new</span> Firebase(<span class="string">'https://docs-examples.firebaseio.com/android/saving-data/fireblog/posts/-JRHTHaIs-jNPLXOQivY/upvotes'</span>);</span><br><span class="line">upvotesRef.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">current_value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (current_value || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h3>
<p>firebase可以绑定比如<code>child_added</code>、<code>Child Removed</code>、<code>value</code>等事件，每当有子元素添加或者值变化时会触发绑定的回调函数。具体调用方法可以参考本文后面提到的方法。</p>
<h2 id="在你的HEXO页面上引入Firebase"><a href="#在你的HEXO页面上引入Firebase" class="headerlink" title="在你的HEXO页面上引入Firebase"></a>在你的HEXO页面上引入Firebase</h2>
<p>在页面的head中引入Firebase的js，<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">'https://cdn.firebase.com/js/client/2.0.4/firebase.js'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>为了加速，也可以将这个js放到自己的七牛云存储上。</p>
<h2 id="增加代码调用Firebase来实现记录访问数"><a href="#增加代码调用Firebase来实现记录访问数" class="headerlink" title="增加代码调用Firebase来实现记录访问数"></a>增加代码调用Firebase来实现记录访问数</h2>
<h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h3>
<p>1.总共记录两类访问记录，一个总数，一个该页面数<br>2.该页面数使用该页面的url作为key值<br>3.每次访问一个页面时，总数+1，本页面数+1<br>4.同时增加记录最后更新时间，和最后更新的那个页面的url</p>
<h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3>
<p>先修改页面的footer用来展示访问记录数，就像这样。当然你可以加在页面的任意位置。<br>
  <figure class="highlight html">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="tag">&lt;<span class="title">footer</span> <span class="attribute">id</span>=<span class="value">"footer"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">%</span> <span class="attribute">if</span> (<span class="attribute">theme.sidebar</span> =<span class="value">==</span> '<span class="attribute">bottom</span>')&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">%-</span> <span class="attribute">partial</span>('<span class="attribute">_partial</span>/<span class="attribute">sidebar</span>') %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">%</span> &#125; %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"outer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">div</span> <span class="attribute">id</span>=<span class="value">"footer-info"</span> <span class="attribute">class</span>=<span class="value">"inner"</span>&gt;</span></span><br><span class="line">      &amp;copy; <span class="tag">&lt;<span class="title">%=</span> <span class="attribute">date</span>(<span class="attribute">new</span> <span class="attribute">Date</span>(), '<span class="attribute">YYYY</span>') %&gt;</span> <span class="tag">&lt;<span class="title">%=</span> <span class="attribute">config.author</span> || <span class="attribute">config.title</span> %&gt;</span><span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">      Powered by <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"http://hexo.io/"</span> <span class="attribute">target</span>=<span class="value">"_blank"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line">      .</span><br><span class="line">      <span class="tag">&lt;<span class="title">font</span> <span class="attribute">id</span>=<span class="value">"sum_counter"</span>&gt;</span><span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">font</span> <span class="attribute">id</span>=<span class="value">"detail_counter"</span>&gt;</span><span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">footer</span>&gt;</span></span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>首先new出自己的Firebase<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="keyword">var</span> io10blogFirebase = <span class="keyword">new</span> Firebase(<span class="string">"https://io10test.firebaseio.com/"</span>);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>然后获取访问总量以及明细<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="comment">// 明细由当前页面的url表示，将反斜线替换成下划线，并将中文decode出来</span></span><br><span class="line"><span class="keyword">var</span> current_url = <span class="built_in">decodeURI</span>(<span class="built_in">window</span>.location.pathname.replace(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\/|\\.'</span>, <span class="string">'g'</span>),<span class="string">"_"</span>));</span><br><span class="line"><span class="comment">// 获取总数，并将总访问量展示在页面上</span></span><br><span class="line">io10blogFirebase.child(<span class="string">"sum"</span>).on(<span class="string">"value"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> current_counter = data.val();</span><br><span class="line">  <span class="keyword">if</span>( $(<span class="string">"#sum_counter"</span>).length &gt; <span class="number">0</span>  &amp;&amp; current_counter &gt;<span class="number">1</span> )&#123;</span><br><span class="line">      $(<span class="string">"#sum_counter"</span>).html(</span><br><span class="line">   	   	<span class="string">"&amp;nbsp;|&amp;nbsp;总访问量&amp;nbsp;&lt;font style='color:white'&gt;"</span>+ current_counter +<span class="string">"&lt;/font&gt;&amp;nbsp;次"</span></span><br><span class="line">       );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 获取明细，并将明细也展示在页面上</span></span><br><span class="line">io10blogFirebase.child(<span class="string">"detail/"</span>+current_url).on(<span class="string">"value"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> detail_counter = data.val();</span><br><span class="line">	<span class="keyword">if</span>($(<span class="string">"#detail_counter"</span>).length &gt; <span class="number">0</span> &amp;&amp; detail_counter &gt; <span class="number">1</span>)&#123;</span><br><span class="line">		$(<span class="string">"#detail_counter"</span>).html(</span><br><span class="line">			<span class="string">"&amp;nbsp;本页访问量&amp;nbsp;&lt;font style='color:white'&gt;"</span>+ detail_counter +<span class="string">"&lt;/font&gt;&amp;nbsp;次"</span></span><br><span class="line">		);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>将访问数+1，包括总数和明细<br>
  <figure class="highlight javascript">
    <table>
      <tr>
        <td class="code">
          <pre><span class="line"><span class="comment">// 总数+1</span></span><br><span class="line">io10blogFirebase.child(<span class="string">"sum"</span>).transaction(<span class="function"><span class="keyword">function</span> (<span class="params">current_counter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (current_counter || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 明细+1</span></span><br><span class="line">io10blogFirebase.child(<span class="string">"detail/"</span>+current_url).transaction(<span class="function"><span class="keyword">function</span> (<span class="params">current_counter</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (current_counter || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre>
        </td>
      </tr>
    </table>
  </figure>
</p>
<p>下面这幅图是Firebase的应用管理界面，这个界面的数也是实时在变化的。</p>
<p><img src="/resources/realtime-count-firebase/FirebaseDash.PNG" alt="DashBoard"></p>
<p>这样，实时访问统计就可以实现啦！这里只是打开了一个思路，Firebase等于给静态网站添加上了可以实时存储于读取数据的翅膀。除了统计访问量，它能做的事情很多很多。甚至替换掉多说，自己实现一个评论系统都是有可能的！<br>
  <span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/02/27/realtime-count-firebase/</p><p>访问原文「<a href='http://www.pangjian.me/2015/02/27/realtime-count-firebase/'>基于Firebase的Hexo博客实时访问数统计</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>

</p>]]></content>
      
        
        <tags>
            
            <tag> firebase </tag>
            
            <tag> hexo </tag>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[第一篇blog]]></title>
      <url>http://www.pangjian.me/2015/02/17/%E7%AC%AC%E4%B8%80%E7%AF%87blog/</url>
      <content type="html"><![CDATA[<p>博客开张啦，这是我的第一篇博客，基于Hexo搭建，部署在Github Page上。</p>
<p>地址：<a href="http://pangjian.me" target="_blank" rel="external">pangjian.me</a></p>
<span class='source'><blockquote class='source'><p>转载请注明出处：http://www.pangjian.me/2015/02/17/第一篇blog/</p><p>访问原文「<a href='http://www.pangjian.me/2015/02/17/第一篇blog/'>第一篇blog</a>」获取最佳阅读体验并参与讨论</p></blockquote></span>
<script type="text/javascript">
(function() {
  Element.prototype.remove = function() {
    this.parentElement.removeChild(this);
  }
  NodeList.prototype.remove = HTMLCollection.prototype.remove = function() {
    for(var i = this.length - 1; i >= 0; i--) {
        if(this[i] && this[i].parentElement) {
            this[i].parentElement.removeChild(this[i]);
        }
    }
  }
  var domain = document.domain;
  var white_list = ['pangjian.info', 'www.pangjian.info', 'pangjian.me', 'www.pangjian.me', 'localhost', '127.0.0.1'];
  if (white_list.indexOf(domain) >= 0) {
    var elements = document.getElementsByClassName('source');
    elements.remove();
  }
})()
</script>
]]></content>
      
        
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
